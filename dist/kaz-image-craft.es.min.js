var R = Object.defineProperty;
var P = (m, e, t) => e in m ? R(m, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : m[e] = t;
var q = (m, e) => () => (e || m((e = { exports: {} }).exports, e), e.exports);
var U = (m, e, t) => P(m, typeof e != "symbol" ? e + "" : e, t);
var N = q((W, $) => {
  /**
   * KazImageCraft.js
   *
   * Provides image preview, editing (crop, rotate, flip), and drag-and-drop reordering.
   * Designed for integration into forms with dynamic UI updates.
   *
   * @version 1.4
   * @author Y D <y@9.kz>
   * @website https://www.kazcms.com/en-us/kaz-image-craft
   * @license MIT
   */
  const w = {
    DEFAULT_CROP_SIZE: 200,
    DEFAULT_ROTATE_CIRCLE_SIZE: 100,
    DEFAULT_OUTPUT_FORMAT: "image/webp",
    DEFAULT_QUALITY: 1,
    MOBILE_BREAKPOINT: 768,
    MAX_RETRY_ATTEMPTS: 3,
    DEBOUNCE_DELAY: 300,
    // Image compression settings
    COMPRESSION: {
      MAX_FILE_SIZE: 2097152,
      // 2MB default
      MAX_WIDTH: 1920,
      MAX_HEIGHT: 1080,
      QUALITY_STEP: 0.1,
      MIN_QUALITY: 0.1,
      RESIZE_STEP: 0.9
    },
    // CSS Classes
    CLASSES: {
      WRAPPER: "kaz-image-craft-wrapper",
      PREVIEW_ITEM: "kaz-image-craft-preview-item",
      IMAGE: "kaz-image-craft-image",
      DELETE_BTN: "kaz-image-craft-delete-btn",
      MOVE_UP: "kaz-image-craft-move-up",
      MOVE_DOWN: "kaz-image-craft-move-down",
      DRAGGING: "kaz-image-craft-dragging",
      DRAG_OVER: "kaz-image-craft-drag-over",
      MODAL: "kaz-image-craft-modal",
      CROP_BOX: "kaz-image-craft-modal-crop-box",
      ROTATE_BOX: "kaz-image-craft-modal-rotate-box",
      COMPRESS_BOX: "kaz-image-craft-modal-compress-box"
    },
    // Event types
    EVENTS: {
      TOUCH_START: "touchstart",
      TOUCH_MOVE: "touchmove",
      TOUCH_END: "touchend",
      MOUSE_DOWN: "mousedown",
      MOUSE_MOVE: "mousemove",
      MOUSE_UP: "mouseup"
    }
  }, h = {
    // Default English messages
    messages: {
      duplicate: (m) => `File "${m}" already exists. Do you want to add it anyway?`,
      removeImage: "Remove image",
      dragDropHint: "Click to select files or drag and drop here",
      rotateAndFlip: "Rotate and Flip",
      reset: "Reset to original",
      download: "Download image",
      previewImage: "Preview image",
      discardEdits: "You have unsaved edits. Do you want to discard them?",
      resetWarning: "Are you sure you want to reset this image to its original state?",
      maxImagesExceeded: (m, e) => `Maximum ${m} images allowed. You already uploaded ${e}.`,
      noImageToDownload: "No image to download",
      cropSizeDisplay: (m, e) => `${Math.round(m)}px √ó ${Math.round(e)}px`,
      // Compression messages
      compressImage: "Compress Image",
      compressionSettings: "Compression Settings",
      resizeByDimensions: "Resize by Dimensions",
      resizeByFileSize: "Resize by File Size",
      maxWidth: "Max Width",
      maxHeight: "Max Height",
      maxFileSize: "Max File Size",
      currentSize: "Current Size",
      targetSize: "Target Size",
      quality: "Quality",
      pixels: "px",
      percentage: "%",
      megabytes: "MB",
      kilobytes: "KB",
      bytes: "bytes",
      apply: "Apply",
      cancel: "Cancel",
      compressing: "Compressing...",
      compressionComplete: "Compression complete",
      compressionFailed: "Compression failed",
      fileSizeReduced: (m, e, t) => `File size reduced from ${m} to ${e} (${t}% reduction)`,
      dimensionsChanged: (m, e, t, a) => `Dimensions changed from ${m}√ó${e} to ${t}√ó${a}`,
      noCompressionNeeded: "Image is already within the specified limits"
    },
    /**
     * Get localized message
     * @param {string} key - Message key
     * @param {...any} args - Arguments for message formatting
     * @returns {string}
     */
    get(m, ...e) {
      const t = this.messages[m];
      return typeof t == "function" ? t(...e) : t || m;
    },
    /**
     * Set custom language messages
     * @param {Object} customMessages - Custom message object
     */
    setMessages(m) {
      this.messages = { ...this.messages, ...m };
    }
  };
  window.kazImageCraftLang = h;
  const v = {
    /**
     * Check if device supports touch events
     * @returns {boolean}
     */
    isTouchDevice() {
      return "ontouchstart" in window || navigator.maxTouchPoints > 0;
    },
    /**
     * Check if device is mobile based on screen width
     * @returns {boolean}
     */
    isMobile() {
      return window.innerWidth <= w.MOBILE_BREAKPOINT;
    },
    /**
     * Generate UUID v4
     * @returns {string}
     */
    generateUUID() {
      return crypto && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (m) => {
        const e = Math.random() * 16 | 0;
        return (m === "x" ? e : e & 3 | 8).toString(16);
      });
    },
    /**
     * Debounce function execution
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in milliseconds
     * @returns {Function}
     */
    debounce(m, e = w.DEBOUNCE_DELAY) {
      let t;
      return function(...i) {
        const s = () => {
          clearTimeout(t), m(...i);
        };
        clearTimeout(t), t = setTimeout(s, e);
      };
    },
    /**
     * Clean up blob URLs to prevent memory leaks
     * @param {string} url - Blob URL to revoke
     */
    revokeBlobUrl(m) {
      m && m.startsWith("blob:") && URL.revokeObjectURL(m);
    },
    /**
     * Safely get element by ID with error handling
     * @param {string} id - Element ID
     * @returns {HTMLElement|null}
     */
    getElementById(m) {
      try {
        return document.getElementById(m);
      } catch (e) {
        return console.warn(`Element with ID "${m}" not found:`, e), null;
      }
    },
    /**
     * Format file size in human readable format
     * @param {number} bytes - File size in bytes
     * @returns {string}
     */
    formatFileSize(m) {
      if (m === 0) return "0 " + h.get("bytes");
      const e = 1024, t = [
        h.get("bytes"),
        h.get("kilobytes"),
        h.get("megabytes"),
        "GB",
        "TB"
      ], a = Math.floor(Math.log(m) / Math.log(e));
      return parseFloat((m / Math.pow(e, a)).toFixed(2)) + " " + t[a];
    },
    /**
     * Parse size string to pixels
     * @param {string} sizeStr - Size string (e.g., "100px", "50%", "100")
     * @param {number} referenceSize - Reference size for percentage calculations
     * @returns {number}
     */
    parseSizeToPixels(m, e = 0) {
      if (typeof m == "number") return m;
      const t = String(m).trim();
      if (!t) return 0;
      if (t.endsWith("%")) {
        const a = parseFloat(t);
        return Math.round(a / 100 * e);
      }
      return t.endsWith("px") ? parseInt(t) : parseInt(t) || 0;
    },
    /**
     * Parse file size string to bytes
     * @param {string} sizeStr - Size string (e.g., "2MB", "500KB", "1024")
     * @returns {number}
     */
    parseSizeToBytes(m) {
      if (typeof m == "number") return m;
      const e = String(m).trim().toUpperCase();
      if (!e) return 0;
      const t = parseFloat(e);
      return isNaN(t) ? 0 : e.includes("GB") ? t * 1024 * 1024 * 1024 : e.includes("MB") ? t * 1024 * 1024 : e.includes("KB") ? t * 1024 : t;
    },
    /**
     * Calculate optimal canvas dimensions while maintaining aspect ratio
     * @param {number} originalWidth - Original width
     * @param {number} originalHeight - Original height
     * @param {number} maxWidth - Maximum width
     * @param {number} maxHeight - Maximum height
     * @returns {Object} - {width, height, scale}
     */
    calculateOptimalDimensions(m, e, t, a) {
      if (!t && !a)
        return { width: m, height: e, scale: 1 };
      let i = t ? t / m : 1, s = a ? a / e : 1;
      const r = Math.min(i, s, 1);
      return {
        width: Math.round(m * r),
        height: Math.round(e * r),
        scale: r
      };
    },
    /**
     * Create element with attributes and classes
     * @param {string} tagName - HTML tag name
     * @param {Object} options - Element options
     * @param {string|Array<string>} options.className - CSS classes
     * @param {Object} options.attributes - HTML attributes
     * @param {string} options.innerHTML - Inner HTML content
     * @returns {HTMLElement}
     */
    createElement(m, e = {}) {
      const t = document.createElement(m);
      if (e.className) {
        const a = Array.isArray(e.className) ? e.className : [e.className];
        t.classList.add(...a);
      }
      return e.attributes && Object.entries(e.attributes).forEach(([a, i]) => {
        t.setAttribute(a, i);
      }), e.innerHTML && (t.innerHTML = e.innerHTML), t;
    }
  }, p = class p {
    /**
     * @constructor
     * @param {HTMLInputElement} fileInput - The original file input element.
     * @param {HTMLElement} previewContainer - Container for image preview items.
     * @param {HTMLFormElement} form - Form element to bind submit events.
     * @param {string} [orderInputName='image_order'] - Name for hidden input fields tracking image order.
     * @param {Object} [config={}] - Configuration options.
     */
    constructor(e, t, a, i = "image_order", s = {}) {
      this.fileInput = e, this.previewContainer = t, this.form = a, this.orderInputName = i, this.config = { ...p.globalConfig, ...s }, this.dragSrcEl = null, this.toolsName = "", this.isEditing = !1, this.cropBox = null, this.rotateBox = null, this.format = this.config.outputFormat || w.DEFAULT_OUTPUT_FORMAT, this.ext = this.format.split("/")[1], this.quality = this.config.quality || w.QUALITY, this.isMobile = v.isMobile(), this.isTouch = v.isTouchDevice(), this.eventCleanupFunctions = [], this._handleFiles = this._handleFiles.bind(this), this._injectFiles = this._injectFiles.bind(this);
    }
    /**
     * Initializes all file inputs and binds KazImageCraft instances to them.
     * @param {Object} options - Configuration options
     * @param {string} options.fileInputClass - CSS class for file inputs
     * @param {string} options.formClass - CSS class for forms
     * @param {Array<string>} options.editableImgClass - CSS classes for editable images
     * @param {Array<string>} options.scanClass - CSS classes to scan for
     * @param {boolean} options.showPreview - Whether to show preview
     * @returns {Promise<void>}
     */
    static async _init(e = {}) {
      const a = { ...{
        fileInputClass: "",
        formClass: "",
        editableImgClass: [],
        // Classes to match on img itself
        scanClass: [],
        showPreview: !0,
        outputFormat: w.DEFAULT_OUTPUT_FORMAT,
        quality: w.DEFAULT_QUALITY
      }, ...e };
      p.globalConfig = a;
      try {
        a.formClass && await p._initUploadMode(a), a.editableImgClass.length && a.scanClass.length && await p._initHtmlEditMode(a);
      } catch (i) {
        throw console.error("Failed to initialize KazImageCraft:", i), i;
      }
    }
    /**
     * Initialize upload mode for file inputs
     * @param {Object} config - Configuration object
     * @private
     */
    static async _initUploadMode(e) {
      const t = document.querySelectorAll(`form.${e.formClass}`);
      for (const a of t) {
        const i = a.querySelectorAll(`input.${e.fileInputClass}[type="file"]`);
        for (const s of i) {
          if (s.dataset.kazInit === "1") continue;
          s.dataset.kazInit = "1";
          const r = p._getOrCreatePreviewContainer(s, a, e), o = "image_order_" + s.name.replace(/\W+/g, "_"), n = new p(s, r, a, o, e);
          await n._bind(), p.instances.push(n);
        }
      }
    }
    /**
     * Initialize HTML edit mode for existing images
     * @param {Object} config - Configuration object
     * @private
     */
    static async _initHtmlEditMode(e) {
      const t = e.scanClass.map((i) => `.${i}`).join(""), a = document.querySelectorAll(t);
      for (const i of a) {
        const s = document.getElementById(i.dataset.preview);
        if (!s) continue;
        const r = p._collectEditableImages(i, e.editableImgClass);
        if (!r.length) continue;
        const o = i.dataset.preview.replace("preview-container-", "");
        p.uploadedImages[o] || (p.uploadedImages[o] = []);
        const n = r.map((c) => ({
          id: v.generateUUID(),
          previewUrl: c.src,
          editedUrl: c.src,
          originalFile: c,
          file: new File([], c.getAttribute("name") || c.src.split("/").pop()),
          element: c,
          container: i
        })), l = new p(null, s, null, `${o}_order`, e);
        l.htmlModeName = o, await l._bind({ existingFiles: n, isHtmlMode: !0, htmlModeName: o }), p.instances.push(l);
      }
    }
    /**
     * Get or create preview container for file input
     * @param {HTMLInputElement} input - File input element
     * @param {HTMLFormElement} form - Form element
     * @param {Object} config - Configuration object
     * @returns {HTMLElement|null}
     * @private
     */
    static _getOrCreatePreviewContainer(e, t, a) {
      if (!a.showPreview) return null;
      let i = e.dataset.preview ? document.getElementById(e.dataset.preview) : t.querySelector(".kaz-image-craft-preview-container");
      if (!i) {
        const s = "PreviewContainer_" + e.name.replace(/\W+/g, "_");
        i = document.createElement("div"), i.id = s, i.classList.add("kaz-preview-container"), e.parentNode.insertBefore(i, e.nextSibling);
      }
      return i;
    }
    /**
     * Collect editable images from wrapper element
     * @param {HTMLElement} wrapper - Wrapper element
     * @param {Array<string>} editableImgClass - CSS classes for editable images
     * @returns {Array<HTMLImageElement>}
     * @private
     */
    static _collectEditableImages(e, t) {
      let a = Array.from(e.querySelectorAll("img"));
      for (const i of t)
        a = a.filter((s) => s.classList.contains(i) || s.closest(`.${i}`));
      return a;
    }
    /**
     * Injects files from all initialized KazImageCraft instances into their respective forms.
     *
     * This method iterates over all KazImageCraft instances created by the static _init method
     * and calls their internal _injectFiles() method to prepare the files for submission.
     *
     * Usage:
     * Call this method before submitting the form programmatically to ensure all selected files
     * are properly injected and included in the form data.
     *
     * Example:
     *   KazImageCraft.injectAllFiles();
     *   form.submit();
     *
     * @static
     * @memberof KazImageCraft
     */
    static injectAllFiles() {
      p.instances.forEach((e) => {
        try {
          e._injectFiles();
        } catch (t) {
          console.error("Error injecting files for uploader:", t);
        }
      });
    }
    /**
     * Clean up all instances and their resources
     * @static
     */
    static cleanupAll() {
      p.instances.forEach((e) => {
        try {
          e.cleanup();
        } catch (t) {
          console.error("Error cleaning up instance:", t);
        }
      }), p.instances = [], p.uploadedImages = {};
    }
    /**
     * Get instance by input name or HTML mode name
     * @param {string} name - Input name or HTML mode name
     * @returns {KazImageCraft|null}
     * @static
     */
    static getInstance(e) {
      return p.instances.find(
        (t) => {
          var a;
          return ((a = t.fileInput) == null ? void 0 : a.name) === e || t.htmlModeName === e;
        }
      ) || null;
    }
    /**
     * Binds events for file input and form submission. Also handles existing image population.
     * @param {Object} options - Binding options
     * @param {Array} options.existingFiles - Existing files to load
     * @param {boolean} options.isHtmlMode - Whether in HTML editing mode
     * @param {string} options.HtmlModeName - Name for HTML mode
     * @private
     */
    async _bind({ existingFiles: e = [], isHtmlMode: t = !1, HtmlModeName: a = "" } = {}) {
      var i, s;
      try {
        this.isHtmlMode = t, t || (this._createWrapper(), this._bindFileInputEvents());
        const r = ((i = this.fileInput) == null ? void 0 : i.name) || a;
        if (!r)
          throw new Error("No input name or HTML mode name provided");
        !t && ((s = this.fileInput) != null && s.dataset.targetExisting) && await this._loadExistingFilesFromInput(r), t && e.length && this._loadExistingFilesFromArray(r, e), typeof this._renderPreview == "function" && this._renderPreview(r);
      } catch (r) {
        throw console.error("Error binding KazImageCraft:", r), r;
      }
    }
    /**
     * Bind file input events
     * @private
     */
    _bindFileInputEvents() {
      if (!this.fileInput) return;
      const e = (t) => this._handleFiles(t.target.files);
      if (this.fileInput.addEventListener("change", e), this.eventCleanupFunctions.push(() => {
        this.fileInput.removeEventListener("change", e);
      }), this.form) {
        const t = () => this._injectFiles();
        this.form.addEventListener("submit", t), this.eventCleanupFunctions.push(() => {
          this.form.removeEventListener("submit", t);
        });
      }
    }
    /**
     * Load existing files from hidden input
     * @param {string} name - Input name
     * @private
     */
    async _loadExistingFilesFromInput(e) {
      const t = document.querySelector(this.fileInput.dataset.targetExisting);
      if (!(!t || !t.value.trim()))
        try {
          let a = t.value.trim();
          a.startsWith("[") && a.includes("'") && (a = a.replace(/'/g, '"'));
          const i = JSON.parse(a);
          Array.isArray(i) && i.length > 0 && await this._loadExistingFiles(e, i);
        } catch (a) {
          console.warn("Invalid existing image data:", t.value, a);
        }
    }
    /**
     * Load existing files from array (HTML mode)
     * @param {string} name - Input name
     * @param {Array} existingFiles - Array of existing file objects
     * @private
     */
    _loadExistingFilesFromArray(e, t) {
      this.htmlModeName = e, p.uploadedImages[e] || (p.uploadedImages[e] = []), t.forEach((a) => {
        if (!a.id || !a.file) {
          console.warn("Invalid image object:", a);
          return;
        }
        p.uploadedImages[e].push(a);
      });
    }
    /**
     * Handles dropped or selected files, checks duplicates and max limits.
     * @param {FileList} files - The list of selected files.
     * @private
     */
    _handleFiles(e) {
      const t = this.fileInput.name;
      p.uploadedImages[t] || (p.uploadedImages[t] = []);
      try {
        const a = this._validateFiles(e, t);
        if (!a.isValid) {
          alert(a.message), this.fileInput.value = "";
          return;
        }
        this._processValidFiles(a.validFiles, t).length > 0 && this._renderPreview(t);
      } catch (a) {
        console.error("Error handling files:", a), alert("An error occurred while processing the files. Please try again.");
      } finally {
        this.fileInput.value = "";
      }
    }
    /**
     * Validate files against constraints
     * @param {FileList} files - Files to validate
     * @param {string} name - Input name
     * @returns {Object} Validation result
     * @private
     */
    _validateFiles(e, t) {
      const a = parseInt(this.fileInput.dataset.max || "0", 10), i = p.uploadedImages[t].length, s = Array.from(e).filter((o) => o.type.startsWith("image/"));
      if (a > 0 && i + s.length > a)
        return {
          isValid: !1,
          message: h.get("maxImagesExceeded", a, i)
        };
      const r = parseInt(this.fileInput.dataset.maxSize || "0", 10);
      return r > 0 && s.filter((n) => n.size > r).length > 0 ? {
        isValid: !1,
        message: `Some files are too large. Maximum file size is ${this._formatFileSize(r)}.`
      } : {
        isValid: !0,
        validFiles: s
      };
    }
    /**
     * Process valid files and add them to the collection
     * @param {Array<File>} files - Valid files to process
     * @param {string} name - Input name
     * @returns {Array} Processed files
     * @private
     */
    _processValidFiles(e, t) {
      const a = [];
      return e.forEach((i) => {
        if (p.uploadedImages[t].some(
          (l) => l.file.name === i.name && l.file.size === i.size
        ) && !confirm(h.get("duplicate", i.name)))
          return;
        const r = v.generateUUID(), o = URL.createObjectURL(i), n = {
          id: r,
          file: i,
          previewUrl: o,
          editedUrl: o,
          originalFile: i
        };
        p.uploadedImages[t].push(n), a.push(n);
      }), a;
    }
    /**
     * Format file size for display
     * @param {number} bytes - File size in bytes
     * @returns {string} Formatted file size
     * @private
     */
    _formatFileSize(e) {
      if (e === 0) return "0 Bytes";
      const t = 1024, a = ["Bytes", "KB", "MB", "GB"], i = Math.floor(Math.log(e) / Math.log(t));
      return parseFloat((e / Math.pow(t, i)).toFixed(2)) + " " + a[i];
    }
    /**
     * Renders image thumbnails in the preview container.
     * @param {string} name - The name of the file input.
     * @private
     */
    _renderPreview(e) {
      if (!this.previewContainer) return;
      this.previewContainer.innerHTML = "";
      const t = p.uploadedImages[e] || [];
      if (t.length === 0) return;
      const a = document.createDocumentFragment();
      t.forEach((i, s) => {
        const r = this._createPreviewItem(i, s, e, t);
        a.appendChild(r);
      }), this.previewContainer.appendChild(a), this._updateOrderInputs();
    }
    /**
     * Create a single preview item element
     * @param {Object} img - Image data object
     * @param {number} idx - Index in the list
     * @param {string} name - Input name
     * @param {Array} list - Full image list
     * @returns {HTMLElement}
     * @private
     */
    _createPreviewItem(e, t, a, i) {
      var l;
      const s = v.createElement("div", {
        className: w.CLASSES.PREVIEW_ITEM,
        attributes: {
          "data-id": e.id,
          "data-img-id": ((l = e.originalFile) == null ? void 0 : l.id) || "",
          draggable: !this.isMobile
        }
      }), r = this._createImageBox(e, t, a), o = v.createElement("div", {
        className: "kaz-image-craft-image-name",
        innerHTML: e.file.name
      }), n = this._createControls(t, i.length, a, s);
      return s.appendChild(r), s.appendChild(o), s.appendChild(n), this.isMobile || this._addDragAndDropEvents(s), s;
    }
    /**
     * Create image box with image and delete button
     * @param {Object} img - Image data
     * @param {number} idx - Index
     * @param {string} name - Input name
     * @returns {HTMLElement}
     * @private
     */
    _createImageBox(e, t, a) {
      var o;
      const i = v.createElement("div", {
        className: "kaz-image-craft-image-box"
      }), s = v.createElement("img", {
        attributes: {
          id: `img-preview-${a}-${e.id}`,
          src: e.editedUrl,
          alt: e.file.name,
          "data-uuid": `${a}-${e.id}`,
          "data-order": t,
          "data-original-id": ((o = e.originalFile) == null ? void 0 : o.id) || "",
          "data-originalSrc": e.previewUrl
        },
        className: w.CLASSES.IMAGE
      }), r = v.createElement("button", {
        className: w.CLASSES.DELETE_BTN,
        attributes: {
          type: "button",
          "aria-label": h.get("removeImage")
        },
        innerHTML: "√ó"
      });
      return s.addEventListener("click", () => {
        this._showImagePreviewModal(e.id, a), this._addImageToKazListContainer(p.uploadedImages[a], a);
      }), r.addEventListener("click", () => {
        this._removeImage(a, t);
      }), i.appendChild(s), i.appendChild(r), i;
    }
    /**
     * Create control buttons for image reordering
     * @param {number} idx - Current index
     * @param {number} totalLength - Total number of images
     * @param {string} name - Input name
     * @param {HTMLElement} div - Container div
     * @returns {HTMLElement}
     * @private
     */
    _createControls(e, t, a, i) {
      const s = v.createElement("div", {
        className: "kaz-image-craft-controls"
      }), r = v.createElement("button", {
        className: w.CLASSES.MOVE_UP,
        attributes: { type: "button" },
        innerHTML: "‚¨ÖÔ∏è"
      }), o = v.createElement("button", {
        className: w.CLASSES.MOVE_DOWN,
        attributes: { type: "button" },
        innerHTML: "‚û°Ô∏è"
      });
      return r.style.display = e === 0 ? "none" : "", o.style.display = e === t - 1 ? "none" : "", r.addEventListener("click", () => this._moveImage(a, i, "up")), o.addEventListener("click", () => this._moveImage(a, i, "down")), s.appendChild(r), s.appendChild(o), s;
    }
    /**
     * Remove image from collection and re-render
     * @param {string} name - Input name
     * @param {number} idx - Index to remove
     * @private
     */
    _removeImage(e, t) {
      var r;
      const a = p.uploadedImages[e];
      if (!a || t < 0 || t >= a.length) return;
      const i = a[t];
      i.previewUrl && v.revokeBlobUrl(i.previewUrl), i.editedUrl && i.editedUrl !== i.previewUrl && v.revokeBlobUrl(i.editedUrl), a.splice(t, 1), this._renderPreview(e);
      const s = ((r = this.config) == null ? void 0 : r.removeLevel) ?? 0;
      this._syncHtmlImagesByPreview(e, t, s);
    }
    /**
     * Add drag and drop event listeners to an element
     * @param {HTMLElement} element - Element to add events to
     * @private
     */
    _addDragAndDropEvents(e) {
      [
        { type: "dragstart", handler: this._handleDragStart.bind(this) },
        { type: "dragover", handler: this._handleDragOver.bind(this) },
        { type: "dragleave", handler: this._handleDragLeave.bind(this) },
        { type: "drop", handler: this._handleDrop.bind(this) },
        { type: "dragend", handler: this._handleDragEnd.bind(this) }
      ].forEach(({ type: a, handler: i }) => {
        e.addEventListener(a, i), this.eventCleanupFunctions.push(() => {
          e.removeEventListener(a, i);
        });
      });
    }
    /**
     * Clean up all event listeners
     * @public
     */
    cleanup() {
      this.eventCleanupFunctions.forEach((e) => e()), this.eventCleanupFunctions = [], Object.values(p.uploadedImages).flat().forEach((e) => {
        e.previewUrl && v.revokeBlobUrl(e.previewUrl), e.editedUrl && e.editedUrl !== e.previewUrl && v.revokeBlobUrl(e.editedUrl);
      });
    }
    _moveImage(e, t, a) {
      const i = t.parentElement, s = a === "up" ? t.previousElementSibling : t.nextElementSibling;
      s && (a === "up" ? i.insertBefore(t, s) : i.insertBefore(s, t), this._reorderImagesByDOM(), this._renderPreview(e), this._syncHtmlImagesByPreview(e));
    }
    /**
     * Injects temporary hidden file inputs into the form before submit.
     * @private
     */
    _injectFiles() {
      if (!this.wrapper) return;
      this.wrapper.querySelectorAll(".temp-file-input").forEach((a) => a.remove());
      const e = this.fileInput.name;
      (p.uploadedImages[e] || []).forEach((a) => {
        if (!a.file) return;
        const i = document.createElement("input");
        i.type = "file", i.name = e.endsWith("[]") ? e : e + "[]", i.classList.add("temp-file-input"), i.style.display = "none";
        const s = new DataTransfer();
        s.items.add(a.file), i.files = s.files, this.wrapper.appendChild(i);
      });
    }
    /**
     * Updates hidden inputs representing the order of uploaded images.
     * @private
     */
    _updateOrderInputs() {
      var a;
      const e = this.isHtmlMode ? this.htmlModeName : (a = this.fileInput) == null ? void 0 : a.name;
      if (!e) return;
      const t = p.uploadedImages[e] || [];
      this.previewContainer.querySelectorAll(".kaz-image-craft-preview-item").forEach((i, s) => {
        const r = parseInt(i.dataset.id, 10), o = t.find((n) => n.id === r);
        o && (o.order = s);
      }), !this.isHtmlMode && this.form && (this.form.querySelectorAll(`input[name^="${this.orderInputName}"]`).forEach((i) => i.remove()), t.forEach((i, s) => {
        const r = document.createElement("input");
        r.type = "hidden", r.name = `${this.orderInputName}[]`, r.value = `new:${s}`, this.form.appendChild(r);
      }));
    }
    /**
     * Handles the drag start event for reordering.
     * @param {DragEvent} e
     * @private
     */
    _handleDragStart(e) {
      this.dragSrcEl = e.currentTarget, this.dragSrcEl.classList.add("kaz-image-craft-dragging"), e.dataTransfer.effectAllowed = "move", e.dataTransfer.setData("text/plain", "");
    }
    /**
     * Handles the drag over event on other image items.
     * @param {DragEvent} e
     * @private
     */
    _handleDragOver(e) {
      e.preventDefault();
      const t = e.currentTarget;
      t !== this.dragSrcEl && t.classList.add("kaz-image-craft-drag-over");
    }
    /**
     * Removes visual indicator during drag leave.
     * @param {DragEvent} e
     * @private
     */
    _handleDragLeave(e) {
      e.currentTarget.classList.remove("kaz-image-craft-drag-over");
    }
    _updateMoveButtons() {
      const e = Array.from(this.previewContainer.children);
      e.forEach((t, a) => {
        const i = t.querySelector(".kaz-image-craft-move-up"), s = t.querySelector(".kaz-image-craft-move-down");
        !i || !s || (i.style.display = "", s.style.display = "", a === 0 && (i.style.display = "none"), a === e.length - 1 && (s.style.display = "none"));
      });
    }
    /**
     * Handles drop and reorders DOM elements and list.
     * @param {DragEvent} e
     * @private
     */
    _handleDrop(e) {
      e.preventDefault();
      const t = e.currentTarget;
      if (t !== this.dragSrcEl) {
        const a = this.previewContainer, i = Array.from(a.children).indexOf(this.dragSrcEl), s = Array.from(a.children).indexOf(t);
        i < s ? a.insertBefore(this.dragSrcEl, t.nextSibling) : a.insertBefore(this.dragSrcEl, t), this._reorderImagesByDOM();
      }
      t.classList.remove("kaz-image-craft-drag-over"), this.dragSrcEl.classList.remove("kaz-image-craft-dragging"), this.dragSrcEl = null, this._updateMoveButtons(), this.isHtmlMode && this._syncHtmlImagesByPreview(this.htmlModeName);
    }
    _syncHtmlImagesByPreview(e, t = null, a = 1) {
      console.log("syncHtmlImagesByPreview", e, t, a);
      const i = p.uploadedImages[e] || [];
      if (!this.config) return;
      const s = this.config;
      console.log("config", s), console.log("name", e);
      const r = document.getElementById(`kaz-editor-content-${e}`);
      if (!r) {
        console.warn(`[KazImageCraft] No editor wrapper found for id kaz-editor-content-${e}`);
        return;
      }
      console.log("wrapper", r);
      const o = Array.from(r.querySelectorAll("img"));
      if (t !== null && t >= 0 && t < o.length) {
        let l = o[t];
        for (let c = 0; c < a && l; c++)
          l = l.parentElement;
        l && (console.log(`üóë Removing img index ${t} (level ${a})`, l), l.remove());
      }
      const n = Array.from(r.querySelectorAll("img"));
      console.log("newImgs", n), n.forEach((l, c) => {
        const d = i[c];
        d && (l.src = d.editedUrl, l.alt = d.file.name, l.dataset.uuid = `${e}-${d.id}`, l.dataset.order = c);
      });
    }
    /**
     * Clears drag-related styles.
     * @private
     */
    _handleDragEnd() {
      this.previewContainer.querySelectorAll(".kaz-image-craft-preview-item").forEach((e) => {
        e.classList.remove("kaz-image-craft-dragging", "kaz-image-craft-drag-over");
      }), this.dragSrcEl = null;
    }
    /**
     * Reorders internal list of images based on preview container DOM order.
     * @private
     */
    _reorderImagesByDOM() {
      const e = this.isHtmlMode ? this.htmlModeName : this.fileInput.name, t = p.uploadedImages[e] || [], a = [];
      this.previewContainer.querySelectorAll(".kaz-image-craft-preview-item").forEach((i) => {
        const s = i.dataset.id, r = t.find((o) => o.id === s);
        r && a.push(r);
      }), p.uploadedImages[e] = a, this._updateOrderInputs();
    }
    /**
     * Creates the wrapper around the hidden file input.
     * @private
     */
    _createWrapper() {
      let e = this.fileInput.nextElementSibling;
      (!e || !e.classList.contains(this.fileInput.classList[0] + "-wrapper")) && (e = document.createElement("div"), e.classList.add(this.fileInput.classList[0] + "-wrapper"), e.classList.add("kaz-image-craft-wrapper"), e.textContent = h.get("dragDropHint"), this.fileInput.parentNode.insertBefore(e, this.fileInput.nextSibling)), this.wrapper = e, this.fileInput.style.display = "none", this._bindWrapperEvents();
    }
    /**
     * Binds click and drag events to the wrapper.
     * @private
     */
    _bindWrapperEvents() {
      this.wrapper.addEventListener("click", () => this.fileInput.click()), this.wrapper.addEventListener("dragover", (e) => {
        e.preventDefault(), this.wrapper.classList.add("hover");
      }), this.wrapper.addEventListener("dragleave", () => {
        this.wrapper.classList.remove("hover");
      }), this.wrapper.addEventListener("drop", (e) => {
        e.preventDefault(), this.wrapper.classList.remove("hover");
        const t = e.dataTransfer.files;
        this._handleFiles(t);
      });
    }
    /**
     * Creates modal dialog for image preview/editing.
     * @private
     */
    _createPreviewModal() {
      if (document.getElementById("kaz-image-preview-modal")) return;
      const e = document.createElement("div");
      e.id = "kaz-image-preview-modal", e.className = "kaz-image-craft-modal", e.style.display = "none", e.innerHTML = `
   
    <div class="kaz-image-craft-modal-backdrop"></div>
    <div class="kaz-image-craft-modal-content">
      <span class="kaz-image-craft-modal-close">&times;</span>
      
      
      <div class="kaz-image-craft-modal-main">
              
              <div class="kaz-image-craft-modal-toolbar">
      

        <div class="kaz-image-craft-tool-item kaz-image-craft-tool-grid" title="${h.get("rotateAndFlip")}">
          <div class="kaz-image-craft-tool-icon-grid">
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="crop">‚úÇÔ∏è</div>
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="rotate">‚ü≥</div>
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="flip-h">‚áã</div>
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="flip-v">‚Üï</div>
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="compress" title="${h.get("compressImage")}">üóúÔ∏è</div>
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="reset" title="${h.get("reset")}">üîÑ</div>
            <div class="kaz-image-craft-tool-icon-cell kaz-tool-item" data-tool="download" title="${h.get("download")}">‚¨áÔ∏è</div>
          </div>
        </div>
      </div>

        
        <div class="kaz-image-craft-modal-image-area">
          <img src="" id="kaz-preview-image" alt="${h.get("previewImage")}" data-uuid="" data-name>
        </div>
      </div>
      
      <div class="kaz-image-craft-modal-image-list">
        <div class="kaz-image-list-container">
          
        </div>
      </div>


    </div>
  `, document.body.appendChild(e), e.querySelector(".kaz-image-craft-modal-close").onclick = e.querySelector(".kaz-image-craft-modal-backdrop").onclick = () => {
        e.style.display = "none";
      }, e.querySelectorAll(".kaz-tool-item").forEach((t) => {
        t.onclick = () => {
          const a = t.dataset.tool;
          a === "crop" && (this.toolsName = "crop", this._enableCrop()), a === "rotate" && (this.toolsName = "rotate", this._enableRotate()), a === "reset" && (this.toolsName = "reset", this._resetImage()), a === "flip-h" && (this.toolsName = "flip-h", this._flipImage("horizontal")), a === "flip-v" && (this.toolsName = "flip-v", this._flipImage("vertical")), a === "compress" && (this.toolsName = "compress", this._enableCompress()), a === "download" && (this.toolsName = "download", this._downloadPreviewImage());
        };
      }), e.querySelectorAll(".kaz-image-item").forEach((t) => {
        t.onclick = () => {
          e.querySelectorAll(".kaz-image-item").forEach((a) => a.classList.remove("active")), t.classList.add("active");
        };
      });
    }
    /**
     * Displays the image editing modal for a selected image.
     * @param {string} imgId - Unique ID of image.
     * @param {string} name - Name of the file input.
     * @private
     */
    _showImagePreviewModal(e, t) {
      this._createPreviewModal();
      const a = document.getElementById("kaz-image-preview-modal"), i = document.getElementById("kaz-preview-image");
      i.src = document.getElementById(`img-preview-${t}-${e}`).src, i.dataset.uuid = e, i.dataset.name = t, a.style.display = "flex";
    }
    _discardEdits() {
      if (document.getElementById("kaz-preview-image")) {
        if (this.cropBox && (this.cropBox.remove(), this.cropBox = null), this.rotateBox) {
          const t = this.rotateBox.querySelector(".kaz-rotate-cancel");
          t && t.click();
        }
        this.toolsName = "", this.isEditing = !1;
      }
    }
    /**
     * Populates modal image list.
     * @param {Array} images
     * @param {string} name
     * @private
     */
    _addImageToKazListContainer(e, t) {
      if (!e) return;
      const a = document.querySelector(".kaz-image-list-container");
      a.innerHTML = "", e.forEach((i) => {
        const s = v.createElement("div", {
          className: "kaz-image-craft-image-preview-item",
          attributes: { "data-id": i.id },
          innerHTML: `<img id="img-${t}-${i.id}" src="${i.editedUrl}" alt="${i.file.name}" class="kaz-image-craft-image">`
        });
        a.appendChild(s), s.addEventListener("click", () => {
          const r = document.getElementById("kaz-preview-image");
          if (this.cropBox || this.rotateBox) {
            if (!confirm(h.get("discardEdits"))) return;
            this._discardEdits();
          }
          a.querySelectorAll(".kaz-image-craft-image-preview-item").forEach((n) => n.classList.remove("active")), s.classList.add("active"), r.src = i.editedUrl, r.dataset.uuid = i.id, r.dataset.name = t;
        });
      });
    }
    /**
     * Enables crop mode.
     * @private
     */
    /**
     * Enable cropping mode (desktop + mobile compatible)
     */
    _enableCrop() {
      const e = document.querySelector(".kaz-image-craft-modal-image-area");
      if (!e || this.cropBox) return;
      const t = "ontouchstart" in window, a = t ? "touchstart" : "mousedown", i = t ? "touchmove" : "mousemove", s = t ? "touchend" : "mouseup", r = document.createElement("div");
      r.className = "kaz-image-craft-modal-crop-box", r.style.top = "50px", r.style.left = "50px", r.style.width = "200px", r.style.height = "200px", r.innerHTML = `
    <span class="kaz-crop-confirm">‚úîÔ∏è</span>
    <span class="kaz-crop-cancel">‚úñÔ∏è</span>
    
      <div class="crop-size-display">200px √ó 200px</div>

  `, e.style.position = "relative", e.appendChild(r), this.cropBox = r;
      const o = r.querySelector(".kaz-crop-confirm"), n = r.querySelector(".kaz-crop-cancel"), l = (d) => {
        d.preventDefault(), this._applyCrop(), r.remove();
      }, c = (d) => {
        d.preventDefault(), r.remove();
      };
      o.onclick = l, n.onclick = c, o.addEventListener("touchend", l), n.addEventListener("touchend", c), ["nw", "ne", "sw", "se"].forEach((d) => {
        const u = document.createElement("div");
        u.className = `crop-handle crop-handle-${d}`, r.appendChild(u);
      }), this.cropBox.querySelectorAll(".crop-handle").forEach((d) => {
        d.addEventListener(a, (u) => {
          u.preventDefault();
          const g = u.touches ? u.touches[0] : u, I = g.clientX, f = g.clientY, y = this.cropBox.getBoundingClientRect(), z = d.className.match(/crop-handle-([a-z]+)/)[1], C = (E) => {
            const L = E.touches ? E.touches[0] : E, B = L.clientX - I, x = L.clientY - f;
            let S = y.width, b = y.height, M = y.top, k = y.left;
            z.includes("e") && (S = y.width + B), z.includes("s") && (b = y.height + x), z.includes("w") && (S = y.width - B, k = y.left + B), z.includes("n") && (b = y.height - x, M = y.top + x);
            const F = this.cropBox.parentElement.getBoundingClientRect();
            this.cropBox.style.width = S + "px", this.cropBox.style.height = b + "px", this.cropBox.style.left = k - F.left + "px", this.cropBox.style.top = M - F.top + "px";
            const T = this.cropBox.querySelector(".crop-size-display");
            T.textContent = `${Math.round(S)}px √ó ${Math.round(b)}px`;
          }, _ = () => {
            window.removeEventListener(i, C), window.removeEventListener(s, _);
          };
          window.addEventListener(i, C), window.addEventListener(s, _);
        });
      }), this._makeCropBoxDraggable(r, { startEvent: a, moveEvent: i, endEvent: s });
    }
    /**
     * Applies cropping to selected image.
     * @private
     */
    _applyCrop() {
      if (!this.cropBox) return;
      const e = document.getElementById("kaz-preview-image"), t = e.getBoundingClientRect(), a = this.cropBox.getBoundingClientRect(), i = e.naturalWidth / e.width, s = e.naturalHeight / e.height, r = (a.left - t.left) * i, o = (a.top - t.top) * s, n = a.width * i, l = a.height * s, c = document.createElement("canvas");
      c.width = n, c.height = l, c.getContext("2d").drawImage(e, r, o, n, l, 0, 0, n, l);
      const u = e.dataset.uuid;
      e.src = c.toDataURL(), this.cropBox.remove(), this.cropBox = null;
      const g = e.dataset.name;
      c.toBlob((I) => {
        const f = new File([I], `${u}.${this.ext || "webp"}`, { type: this.format || "image/webp" });
        this.updateEditedImage(u, g, c.toDataURL(), f);
      }, this.format || "image/webp", 1);
    }
    /**
     * Makes crop box draggable.
     * @param {HTMLElement} box
     * @private
     */
    _makeCropBoxDraggable(e) {
      const t = e.parentElement;
      if (!t) return;
      let a = !1, i = 0, s = 0;
      const r = (l) => {
        if (l.target.classList.contains("crop-handle")) return;
        l.preventDefault(), a = !0;
        const c = l.touches ? l.touches[0] : l, d = e.getBoundingClientRect();
        i = c.clientX - d.left, s = c.clientY - d.top;
      }, o = (l) => {
        if (!a) return;
        const c = l.touches ? l.touches[0] : l, d = t.getBoundingClientRect();
        let u = c.clientX - d.left - i, g = c.clientY - d.top - s;
        u = Math.max(0, Math.min(u, t.clientWidth - e.offsetWidth)), g = Math.max(0, Math.min(g, t.clientHeight - e.offsetHeight)), e.style.left = u + "px", e.style.top = g + "px";
      }, n = () => {
        a = !1;
      };
      e.addEventListener("mousedown", r), e.addEventListener("touchstart", r, { passive: !1 }), window.addEventListener("mousemove", o), window.addEventListener("touchmove", o, { passive: !1 }), window.addEventListener("mouseup", n), window.addEventListener("touchend", n);
    }
    /**
     * Enables rotation UI.
     * @private
     */
    _enableRotate() {
      const e = document.querySelector(".kaz-image-craft-modal-image-area");
      if (!e) return;
      this.rotateBox && (this.rotateBox.remove(), this.rotateBox = null);
      const t = document.createElement("div");
      t.className = "kaz-image-craft-modal-rotate-box", t.innerHTML = `
      <span class="kaz-rotate-confirm" style="cursor:pointer;">‚úîÔ∏è</span>
      <span class="kaz-rotate-cancel" style="cursor:pointer; margin-left:10px;">‚úñÔ∏è</span>
      <div class="rotate-circle">
        <div class="rotate-center">+</div>
      </div>
    `, e.style.position = "relative", e.appendChild(t), this.rotateBox = t;
      const a = document.getElementById("kaz-preview-image");
      if (!a) return;
      const i = a.getBoundingClientRect(), s = e.getBoundingClientRect(), r = i.left - s.left, o = i.top - s.top, n = r + i.width / 2, l = o + i.height / 2, c = t.querySelector(".rotate-circle"), d = t.querySelector(".rotate-center");
      Object.assign(c.style, {
        position: "absolute",
        width: "100px",
        height: "100px",
        border: "1px dashed rgba(153, 153, 153, 0.7)",
        borderRadius: "50%",
        left: `${n - 50}px`,
        top: `${l - 50}px`,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        cursor: "grab",
        userSelect: "none",
        backgroundColor: "rgba(255, 255, 255, 0.6)",
        boxShadow: "0 0 5px rgba(255,255,255,0.5)"
      }), Object.assign(d.style, {
        width: "50px",
        height: "50px",
        textAlign: "center",
        lineHeight: "50px",
        fontWeight: "bold",
        color: "red",
        cursor: "move",
        userSelect: "none",
        backgroundColor: "rgba(255, 255, 255, 0.5)",
        borderRadius: "50%",
        boxShadow: "0 0 5px rgba(255,0,0,0.7)"
      });
      let u = { x: n, y: l }, g = 0, I = a.style.transform || "";
      const f = "ontouchstart" in window, y = (E) => {
        E.preventDefault();
        const L = f ? E.touches[0].clientX : E.clientX, B = f ? E.touches[0].clientY : E.clientY;
        let x = L, S = B;
        const b = (k) => {
          const F = f ? k.touches[0].clientX : k.clientX, T = f ? k.touches[0].clientY : k.clientY, D = F - x, O = T - S;
          u.x += D, u.y += O, c.style.left = `${u.x - 50}px`, c.style.top = `${u.y - 50}px`, x = F, S = T;
        }, M = () => {
          window.removeEventListener(f ? "touchmove" : "mousemove", b), window.removeEventListener(f ? "touchend" : "mouseup", M);
        };
        window.addEventListener(f ? "touchmove" : "mousemove", b), window.addEventListener(f ? "touchend" : "mouseup", M);
      };
      d.addEventListener(f ? "touchstart" : "mousedown", y);
      const z = (E) => {
        if (E.target === d) return;
        E.preventDefault();
        const L = (x) => {
          const S = f ? x.touches[0].clientX : x.clientX, b = f ? x.touches[0].clientY : x.clientY, M = S - (s.left + u.x), k = b - (s.top + u.y);
          g = Math.atan2(k, M) * 180 / Math.PI;
          const T = u.x - r, D = u.y - o;
          a.style.transformOrigin = `${T}px ${D}px`, a.style.transform = `rotate(${g}deg)`;
        }, B = () => {
          window.removeEventListener(f ? "touchmove" : "mousemove", L), window.removeEventListener(f ? "touchend" : "mouseup", B);
        };
        window.addEventListener(f ? "touchmove" : "mousemove", L), window.addEventListener(f ? "touchend" : "mouseup", B);
      };
      c.addEventListener(f ? "touchstart" : "mousedown", z);
      const C = t.querySelector(".kaz-rotate-confirm"), _ = t.querySelector(".kaz-rotate-cancel");
      C.addEventListener("click", () => {
        this._applyRotationToCanvas(a, g, u, r, o), t.remove(), this.rotateBox = null;
      }), _.addEventListener("click", () => {
        a.style.transform = I, t.remove(), this.rotateBox = null;
      }), f && (C.addEventListener("touchend", (E) => {
        E.preventDefault(), C.click();
      }), _.addEventListener("touchend", (E) => {
        E.preventDefault(), _.click();
      }));
    }
    /**
     * Applies rotation to canvas and updates image preview.
     * @private
     */
    _applyRotationToCanvas(e, t, a, i, s) {
      const r = document.createElement("canvas"), o = r.getContext("2d"), n = e.naturalWidth, l = e.naturalHeight, c = e.getBoundingClientRect(), d = n / c.width, u = l / c.height;
      r.width = n, r.height = l;
      const g = (a.x - i) * d, I = (a.y - s) * u;
      o.clearRect(0, 0, r.width, r.height), o.translate(g, I), o.rotate(t * Math.PI / 180), o.drawImage(e, -g, -I, n, l);
      const f = r.toDataURL(), y = e.dataset.name, z = e.dataset.uuid || e.dataset.id || "";
      r.toBlob((C) => {
        const _ = new File([C], `${z}.${this.ext || "webp"}`, { type: this.format || "image/webp" });
        this.updateEditedImage(z, y, f, _);
      }, this.format || "image/webp", 1), e.src = f, e.style.transform = "";
    }
    /**
     * Enables image flip in given direction.
     * @param {'horizontal'|'vertical'} direction
     * @private
     */
    _flipImage(e) {
      const t = document.getElementById("kaz-preview-image");
      if (!t) return;
      const a = t.dataset.uuid, i = t.dataset.name, s = document.createElement("canvas"), r = s.getContext("2d"), o = t.naturalWidth, n = t.naturalHeight;
      s.width = o, s.height = n, r.save(), e === "horizontal" ? (r.scale(-1, 1), r.drawImage(t, -o, 0)) : e === "vertical" && (r.scale(1, -1), r.drawImage(t, 0, -n)), r.restore();
      const l = s.toDataURL();
      t.src = l, s.toBlob((c) => {
        const d = new File([c], `${a}.${this.ext || "webp"}`, { type: this.format || "image/webp" });
        this.updateEditedImage(a, i, l, d);
      }, this.format || "image/webp", 1);
    }
    _downloadPreviewImage() {
      const e = document.getElementById("kaz-preview-image");
      if (!e || !e.src) {
        alert("No image to download");
        return;
      }
      const t = document.createElement("a");
      t.href = e.src;
      const a = e.dataset.name || "kaz-image.png";
      t.download = a, document.body.appendChild(t), t.click(), document.body.removeChild(t);
    }
    /**
     * Enables image compression interface.
     * @private
     */
    _enableCompress() {
      const e = document.getElementById("kaz-preview-image");
      e && this._createCompressBox(e);
    }
    /**
     * Creates compression settings interface.
     * @param {HTMLImageElement} image - Target image element
     * @private
     */
    _createCompressBox(e) {
      this._removeCompressBox();
      const t = document.getElementById("kaz-image-preview-modal");
      if (!t) return;
      const a = document.createElement("div");
      a.className = w.CLASSES.COMPRESS_BOX, a.innerHTML = this._getCompressBoxHTML(e), t.querySelector(".kaz-image-craft-modal-content").appendChild(a), this.compressBox = a, this._bindCompressEvents(e);
    }
    /**
     * Generates HTML for compression settings box.
     * @param {HTMLImageElement} image - Target image element
     * @returns {string}
     * @private
     */
    _getCompressBoxHTML(e) {
      const t = e.naturalWidth, a = e.naturalHeight, i = this._estimateFileSize(e);
      return `
      <div class="kaz-compress-header">
        <h3>${h.get("compressionSettings")}</h3>
        <button class="kaz-compress-close" type="button">&times;</button>
      </div>

      <div class="kaz-compress-content">
        <div class="kaz-compress-tabs">
          <button class="kaz-compress-tab active" data-tab="dimensions">${h.get("resizeByDimensions")}</button>
          <button class="kaz-compress-tab" data-tab="filesize">${h.get("resizeByFileSize")}</button>
        </div>

        <div class="kaz-compress-tab-content" id="dimensions-tab">
          <div class="kaz-compress-row">
            <label>${h.get("currentSize")}: ${t} √ó ${a} ${h.get("pixels")}</label>
          </div>

          <div class="kaz-compress-row">
            <div class="kaz-compress-input-group">
              <label for="compress-max-width">${h.get("maxWidth")}</label>
              <input type="number" id="compress-max-width" value="${t}" min="1" max="${t}">
              <span>${h.get("pixels")}</span>
            </div>

            <div class="kaz-compress-input-group">
              <label for="compress-max-height">${h.get("maxHeight")}</label>
              <input type="number" id="compress-max-height" value="${a}" min="1" max="${a}">
              <span>${h.get("pixels")}</span>
            </div>
          </div>

          <div class="kaz-compress-row">
            <label>
              <input type="checkbox" id="compress-maintain-ratio" checked>
              Maintain aspect ratio
            </label>
          </div>
        </div>

        <div class="kaz-compress-tab-content" id="filesize-tab" style="display: none;">
          <div class="kaz-compress-row">
            <label>${h.get("currentSize")}: ${v.formatFileSize(i)}</label>
          </div>

          <div class="kaz-compress-row">
            <div class="kaz-compress-input-group">
              <label for="compress-max-filesize">${h.get("maxFileSize")}</label>
              <input type="number" id="compress-max-filesize" value="2" min="0.1" max="50" step="0.1">
              <select id="compress-filesize-unit">
                <option value="MB" selected>${h.get("megabytes")}</option>
                <option value="KB">${h.get("kilobytes")}</option>
              </select>
            </div>
          </div>
        </div>

        <div class="kaz-compress-row">
          <div class="kaz-compress-input-group">
            <label for="compress-quality">${h.get("quality")}</label>
            <input type="range" id="compress-quality" min="0.1" max="1" step="0.1" value="0.8">
            <span id="compress-quality-value">80%</span>
          </div>
        </div>

        <div class="kaz-compress-preview">
          <div id="compress-preview-info"></div>
        </div>
      </div>

      <div class="kaz-compress-footer">
        <button class="kaz-compress-btn kaz-compress-cancel">${h.get("cancel")}</button>
        <button class="kaz-compress-btn kaz-compress-apply">${h.get("apply")}</button>
      </div>
    `;
    }
    /**
     * Binds events for compression interface.
     * @param {HTMLImageElement} image - Target image element
     * @private
     */
    _bindCompressEvents(e) {
      const t = this.compressBox;
      if (!t) return;
      t.querySelectorAll(".kaz-compress-tab").forEach((l) => {
        l.addEventListener("click", () => {
          t.querySelectorAll(".kaz-compress-tab").forEach((d) => d.classList.remove("active")), t.querySelectorAll(".kaz-compress-tab-content").forEach((d) => d.style.display = "none"), l.classList.add("active");
          const c = l.dataset.tab + "-tab";
          t.querySelector(`#${c}`).style.display = "block";
        });
      });
      const a = t.querySelector("#compress-quality"), i = t.querySelector("#compress-quality-value");
      a.addEventListener("input", () => {
        i.textContent = Math.round(a.value * 100) + "%", this._updateCompressPreview(e);
      });
      const s = t.querySelector("#compress-max-width"), r = t.querySelector("#compress-max-height"), o = t.querySelector("#compress-maintain-ratio"), n = (l) => {
        if (o.checked) {
          const c = e.naturalWidth / e.naturalHeight;
          l === s ? r.value = Math.round(s.value / c) : s.value = Math.round(r.value * c);
        }
        this._updateCompressPreview(e);
      };
      s.addEventListener("input", () => n(s)), r.addEventListener("input", () => n(r)), o.addEventListener("change", () => this._updateCompressPreview(e)), t.querySelector("#compress-max-filesize").addEventListener("input", () => {
        this._updateCompressPreview(e);
      }), t.querySelector(".kaz-compress-close").addEventListener("click", () => {
        this._removeCompressBox();
      }), t.querySelector(".kaz-compress-cancel").addEventListener("click", () => {
        this._removeCompressBox();
      }), t.querySelector(".kaz-compress-apply").addEventListener("click", () => {
        this._applyCompress(e);
      }), this._updateCompressPreview(e);
    }
    /**
     * Removes compression settings box.
     * @private
     */
    _removeCompressBox() {
      this.compressBox && (this.compressBox.remove(), this.compressBox = null);
    }
    /**
     * Updates compression preview information.
     * @param {HTMLImageElement} image - Target image element
     * @private
     */
    _updateCompressPreview(e) {
      const t = this.compressBox;
      if (!t) return;
      const a = t.querySelector("#compress-preview-info"), i = t.querySelector(".kaz-compress-tab.active").dataset.tab, s = parseFloat(t.querySelector("#compress-quality").value);
      let r, o, n;
      if (i === "dimensions") {
        r = parseInt(t.querySelector("#compress-max-width").value) || e.naturalWidth, o = parseInt(t.querySelector("#compress-max-height").value) || e.naturalHeight;
        const { width: d, height: u } = v.calculateOptimalDimensions(
          e.naturalWidth,
          e.naturalHeight,
          r,
          o
        );
        r = d, o = u, n = this._estimateCompressedFileSize(e, r, o, s);
      } else {
        const d = parseFloat(t.querySelector("#compress-max-filesize").value) || 2, u = t.querySelector("#compress-filesize-unit").value;
        n = v.parseSizeToBytes(d + u);
        const g = this._calculateDimensionsForFileSize(e, n, s);
        r = g.width, o = g.height;
      }
      const l = this._estimateFileSize(e), c = Math.round((1 - n / l) * 100);
      a.innerHTML = `
      <div class="kaz-compress-preview-item">
        <strong>${h.get("targetSize")}:</strong> ${r} √ó ${o} ${h.get("pixels")}
      </div>
      <div class="kaz-compress-preview-item">
        <strong>${h.get("targetSize")}:</strong> ${v.formatFileSize(n)}
      </div>
      <div class="kaz-compress-preview-item">
        <strong>Reduction:</strong> ${c > 0 ? c + "%" : "No reduction"}
      </div>
    `;
    }
    /**
     * Applies compression to the image.
     * @param {HTMLImageElement} image - Target image element
     * @private
     */
    async _applyCompress(e) {
      const t = this.compressBox;
      if (!t) return;
      const a = t.querySelector(".kaz-compress-apply"), i = a.textContent;
      a.textContent = h.get("compressing"), a.disabled = !0;
      try {
        const s = t.querySelector(".kaz-compress-tab.active").dataset.tab, r = parseFloat(t.querySelector("#compress-quality").value);
        let o, n, l;
        if (s === "dimensions") {
          o = parseInt(t.querySelector("#compress-max-width").value) || e.naturalWidth, n = parseInt(t.querySelector("#compress-max-height").value) || e.naturalHeight;
          const { width: d, height: u } = v.calculateOptimalDimensions(
            e.naturalWidth,
            e.naturalHeight,
            o,
            n
          );
          o = d, n = u;
        } else {
          const d = parseFloat(t.querySelector("#compress-max-filesize").value) || 2, u = t.querySelector("#compress-filesize-unit").value;
          l = v.parseSizeToBytes(d + u);
          const g = this._calculateDimensionsForFileSize(e, l, r);
          o = g.width, n = g.height;
        }
        const c = await this._compressImage(e, o, n, r, l);
        if (c) {
          e.src = c.dataURL;
          const d = e.dataset.uuid, u = e.dataset.name;
          this.updateEditedImage(d, u, c.dataURL, c.file), console.log(h.get("compressionComplete"));
        }
        this._removeCompressBox();
      } catch (s) {
        console.error("Compression failed:", s), alert(h.get("compressionFailed"));
      } finally {
        a.textContent = i, a.disabled = !1;
      }
    }
    /**
     * Resets edited image to original preview.
     * @private
     */
    _resetImage(e = !0) {
      var d;
      const t = document.getElementById("kaz-preview-image");
      if (!t) return;
      const a = t.dataset.uuid, i = t.dataset.name;
      if (!a || !i) return;
      const s = `img-${i}-${a}`, r = `img-preview-${i}-${a}`, o = document.getElementById(r);
      if (!o) return;
      const n = o.dataset.originalsrc;
      if (!n || e && !confirm(h.get("resetWarning"))) return;
      const l = (d = p.uploadedImages[i]) == null ? void 0 : d.find((u) => u.id === a);
      l && (l.editedUrl = null, l.file = l.originalFile), t.src = n;
      const c = document.getElementById(s);
      c && (c.src = n), o.src = n;
    }
    /**
     * Syncs the cropped DataURL and File back to the upload list, and refreshes the preview image.
     *
     * @param {string} id        The image UUID
     * @param {string} name      The <input name="‚Ä¶"> key, i.e. the key of uploadedImages
     * @param {string} dataURL   The cropped base64 DataURL
     * @param {File}   newFile   The cropped File object
     */
    updateEditedImage(e, t, a, i, s = !0) {
      const r = p.uploadedImages[t];
      if (!r) return;
      const o = r.find((d) => d.id === e);
      if (!o) {
        console.warn(`Image with id=${e} not found in uploadedImages[${t}]`);
        return;
      }
      let n = a;
      if (s && a.startsWith("data:")) {
        const d = a.split(","), u = d[0].match(/:(.*?);/)[1], g = atob(d[1]);
        let I = g.length;
        const f = new Uint8Array(I);
        for (; I--; ) f[I] = g.charCodeAt(I);
        const y = new Blob([f], { type: u });
        n = URL.createObjectURL(y);
      }
      o.editedUrl = n, i && (o.file = i);
      const l = document.getElementById(`img-${t}-${e}`);
      l && (l.src = n);
      const c = document.getElementById(`img-preview-${t}-${e}`);
      c && (c.src = n), this._syncHtmlImagesByPreview(t);
    }
    /**
     * Generate UUID (delegated to Utils)
     * @returns {string}
     * @deprecated Use Utils.generateUUID() instead
     */
    generateUUID() {
      return v.generateUUID();
    }
    /**
     * Loads existing images from URLs by fetching them as Blob objects,
     * converts to File instances with proper names and MIME types,
     * and stores them in the uploadedImages collection.
     * 
     * @param {string} name - The input name key for grouping images.
     * @param {string[]} urls - Array of image URLs to load.
     * @returns {Promise<void>} - Resolves when all files are loaded and stored.
     * 
     * Usage:
     * await kazImageCraftInstance._loadExistingFiles('myInputName', [
     *   'http://example.com/image1.jpg',
     *   'http://example.com/photo.png'
     * ]);
     */
    async _loadExistingFiles(e, t) {
      p.uploadedImages[e] || (p.uploadedImages[e] = []);
      for (let a = 0; a < t.length; a++) {
        const i = t[a];
        try {
          const s = await fetch(i);
          if (!s.ok) {
            console.warn(`Failed to fetch image at ${i}`);
            continue;
          }
          const r = await s.blob();
          let o = i.match(/\.(\w+)(?:\?|#|$)/), n = o ? o[1].toLowerCase() : "png";
          const l = `existing_${a + 1}.${n}`, c = new File([r], l, { type: r.type }), d = v.generateUUID();
          p.uploadedImages[e].push({
            id: d,
            file: c,
            previewUrl: i,
            originalFile: c,
            editedUrl: i
          });
        } catch (s) {
          console.warn(`Error loading image from ${i}:`, s);
        }
      }
      this._renderPreview(e);
    }
    /**
     * Estimates current file size of an image element.
     * @param {HTMLImageElement} image - Image element
     * @returns {number} Estimated file size in bytes
     * @private
     */
    _estimateFileSize(e) {
      const t = e.naturalWidth, a = e.naturalHeight, i = t * a;
      return Math.round(i * 1.2);
    }
    /**
     * Estimates compressed file size.
     * @param {HTMLImageElement} image - Source image
     * @param {number} targetWidth - Target width
     * @param {number} targetHeight - Target height
     * @param {number} quality - Compression quality (0-1)
     * @returns {number} Estimated file size in bytes
     * @private
     */
    _estimateCompressedFileSize(e, t, a, i) {
      const s = t * a, o = 1.2 * Math.max(0.1, i);
      return Math.round(s * o);
    }
    /**
     * Calculates optimal dimensions to achieve target file size.
     * @param {HTMLImageElement} image - Source image
     * @param {number} targetFileSize - Target file size in bytes
     * @param {number} quality - Compression quality (0-1)
     * @returns {Object} {width, height}
     * @private
     */
    _calculateDimensionsForFileSize(e, t, a) {
      const i = e.naturalWidth, s = e.naturalHeight, r = i / s, n = 1.2 * Math.max(0.1, a), l = t / n, c = Math.sqrt(l * r), d = l / c;
      return {
        width: Math.min(Math.round(c), i),
        height: Math.min(Math.round(d), s)
      };
    }
    /**
     * Compresses an image to specified dimensions and quality.
     * @param {HTMLImageElement} image - Source image
     * @param {number} targetWidth - Target width
     * @param {number} targetHeight - Target height
     * @param {number} quality - Compression quality (0-1)
     * @param {number} [maxFileSize] - Maximum file size in bytes
     * @returns {Promise<Object>} {dataURL, file, finalQuality}
     * @private
     */
    async _compressImage(e, t, a, i, s = null) {
      return new Promise((r, o) => {
        try {
          const n = document.createElement("canvas"), l = n.getContext("2d");
          n.width = t, n.height = a, l.drawImage(e, 0, 0, t, a);
          let c = i;
          const d = this.format || w.DEFAULT_OUTPUT_FORMAT, u = () => {
            n.toBlob((g) => {
              if (!g) {
                o(new Error("Failed to create blob"));
                return;
              }
              if (s && g.size > s && c > w.COMPRESSION.MIN_QUALITY) {
                c = Math.max(
                  w.COMPRESSION.MIN_QUALITY,
                  c - w.COMPRESSION.QUALITY_STEP
                ), u();
                return;
              }
              const f = `${e.dataset.uuid || v.generateUUID()}.${this.ext || "webp"}`, y = new File([g], f, { type: d });
              r({
                dataURL: n.toDataURL(d, c),
                file: y,
                finalQuality: c,
                finalSize: g.size
              });
            }, d, c);
          };
          u();
        } catch (n) {
          o(n);
        }
      });
    }
    /**
     * Compresses image by file size with iterative quality reduction.
     * @param {HTMLImageElement} image - Source image
     * @param {number} maxFileSize - Maximum file size in bytes
     * @param {number} initialQuality - Initial quality (0-1)
     * @returns {Promise<Object>} Compression result
     * @private
     */
    async _compressToFileSize(e, t, a = 0.8) {
      let i = e.naturalWidth, s = e.naturalHeight, r = a;
      const o = 10;
      let n = 0;
      for (; n < o; ) {
        const l = await this._compressImage(e, i, s, r);
        if (l.finalSize <= t)
          return l;
        r <= w.COMPRESSION.MIN_QUALITY ? (i = Math.round(i * w.COMPRESSION.RESIZE_STEP), s = Math.round(s * w.COMPRESSION.RESIZE_STEP), r = a) : r = Math.max(
          w.COMPRESSION.MIN_QUALITY,
          r - w.COMPRESSION.QUALITY_STEP
        ), n++;
      }
      return this._compressImage(e, i, s, r);
    }
  };
  /**
   * Global storage for all uploaded images grouped by input name.
   * @type {Object.<string, Array<{id: string, file: File, previewUrl: string, editedUrl: string}>>}
   */
  U(p, "uploadedImages", {}), U(p, "instances", []), U(p, "globalConfig", {});
  let A = p;
  typeof $ < "u" && $.exports && ($.exports = { KazImageCraft: A, Utils: v, Lang: h, CONSTANTS: w });
  window.KazImageCraft = A;
  window.KazImageCraftUtils = v;
  window.KazImageCraftLang = h;
  window.KazImageCraftConstants = w;
});
export default N();
